name: Publish Package to npm

# 重要：npm 认证配置说明
# 1. 需要在 npmjs.com 创建 Granular Access Token
# 2. Token 类型选择 "Automation"
# 3. 权限需要包含：Read packages, Write packages
# 4. 必须启用 "Bypass 2FA" 选项（这是发布包所必需的）
# 5. 将 token 添加到 GitHub Secrets 中，名称为 NPM_TOKEN

on:
  push:
    tags:
      - 'logger-v*'  # logger 包格式：logger-v1.0.0, logger-v1.0.0-alpha.1, logger-v1.0.0-beta.2
      - 'v*'         # 简化格式：v1.0.0, v1.0.0-alpha.1, v1.0.0-beta.2 (默认 logger 包)
      # 后续可添加其他包的格式，如：'other-package-v*'
      # 支持预发布版本：alpha (alpha.1, alpha.2...), beta (beta.1, beta.2...), rc (rc.1, rc.2...)

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # 需要写权限以更新 tag 和提交版本更新
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 需要完整历史以处理 tag

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'
          # 使用 NPM_TOKEN 进行认证（需要 Granular Access Token 并启用 bypass 2FA）
          scope: '@traceway'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Parse tag and extract package info
        id: parse-tag
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          
          # 解析包名和版本号
          if [[ "$TAG_NAME" =~ ^logger-v(.+)$ ]]; then
            # 格式：logger-v1.0.0
            PACKAGE_NAME="logger"
            VERSION="${BASH_REMATCH[1]}"
          elif [[ "$TAG_NAME" =~ ^v(.+)$ ]]; then
            # 格式：v1.0.0 (默认 logger 包)
            PACKAGE_NAME="logger"
            VERSION="${BASH_REMATCH[1]}"
          else
            echo "Error: Invalid tag format. Expected 'logger-v*' or 'v*'"
            exit 1
          fi
          
          echo "package_name=$PACKAGE_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
          # 验证版本号格式 (semver，支持预发布版本如 alpha、beta、rc)
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$ ]]; then
            echo "Error: Invalid version format. Expected semver format (e.g., 1.0.0, 1.0.0-alpha.1, 1.0.0-beta.2, 1.0.0-rc.1)"
            exit 1
          fi
          
          # 检测预发布版本类型（alpha、beta、rc）
          if [[ "$VERSION" =~ -alpha\. ]]; then
            PRE_RELEASE_TAG="alpha"
          elif [[ "$VERSION" =~ -beta\. ]]; then
            PRE_RELEASE_TAG="beta"
          elif [[ "$VERSION" =~ -rc\. ]]; then
            PRE_RELEASE_TAG="rc"
          else
            PRE_RELEASE_TAG="latest"
          fi
          
          echo "pre_release_tag=$PRE_RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "Parsed package: $PACKAGE_NAME, version: $VERSION, dist-tag: $PRE_RELEASE_TAG"

      - name: Update package.json version
        run: |
          PACKAGE_NAME="${{ steps.parse-tag.outputs.package_name }}"
          VERSION="${{ steps.parse-tag.outputs.version }}"
          PACKAGE_DIR="packages/$PACKAGE_NAME"
          
          if [ ! -d "$PACKAGE_DIR" ]; then
            echo "Error: Package directory $PACKAGE_DIR does not exist"
            exit 1
          fi
          
          # 更新包的 package.json
          cd "$PACKAGE_DIR"
          npm version "$VERSION" --no-git-tag-version --allow-same-version
          
          # 如果根目录有 package.json，也更新版本
          cd ../..
          if [ -f "package.json" ]; then
            npm version "$VERSION" --no-git-tag-version --allow-same-version || true
          fi
          
          echo "Updated $PACKAGE_NAME to version $VERSION"

      - name: Install dependencies
        run: |
          # 检查 lockfile 是否存在，如果不存在或版本不兼容则生成新的
          if [ ! -f "pnpm-lock.yaml" ]; then
            echo "pnpm-lock.yaml not found, generating new lockfile"
            pnpm install --no-frozen-lockfile
          else
            # 尝试使用 frozen-lockfile，如果失败则回退到普通安装
            pnpm install --frozen-lockfile || pnpm install
          fi

      - name: Run tests
        run: |
          PACKAGE_NAME="${{ steps.parse-tag.outputs.package_name }}"
          cd "packages/$PACKAGE_NAME"
          
          # 检查 package.json 中是否有 test 脚本
          if grep -q '"test"' package.json; then
            echo "Running tests..."
            # 在 CI 环境中使用 --run 参数确保测试完成后退出
            pnpm test:run || pnpm test --run || pnpm test
          else
            echo "No test script found in package.json, skipping tests"
          fi

      - name: Build package
        run: |
          PACKAGE_NAME="${{ steps.parse-tag.outputs.package_name }}"
          cd "packages/$PACKAGE_NAME"
          pnpm build
          
          # 验证构建产物存在
          if [ ! -d "dist" ] || [ -z "$(ls -A dist)" ]; then
            echo "Error: Build output directory 'dist' is empty or does not exist"
            exit 1
          fi
          echo "Build completed successfully"

      - name: Configure npm for publishing
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          # actions/setup-node 已经配置了认证，这里只需要确保配置正确
          # 验证 token 是否有效
          if [ -z "$NODE_AUTH_TOKEN" ]; then
            echo "Error: NPM_TOKEN secret is not set"
            exit 1
          fi
          
          # 显示配置信息（不显示 token）
          echo "npm registry configured for @traceway scope"
          npm config get registry
          
          # 验证 token 权限（不显示敏感信息）
          echo "Verifying npm authentication..."
          if npm whoami --registry https://registry.npmjs.org/ > /dev/null 2>&1; then
            echo "✓ npm authentication successful"
            npm whoami --registry https://registry.npmjs.org/
          else
            echo "✗ npm authentication failed"
            echo "Please ensure:"
            echo "1. NPM_TOKEN is a Granular Access Token (not Classic Token)"
            echo "2. Token type is 'Automation'"
            echo "3. Token has 'Bypass 2FA' enabled"
            echo "4. Token has 'Read packages' and 'Write packages' permissions"
            echo "5. Token has access to @traceway scope"
            exit 1
          fi

      - name: Publish to npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          PACKAGE_NAME="${{ steps.parse-tag.outputs.package_name }}"
          VERSION="${{ steps.parse-tag.outputs.version }}"
          PRE_RELEASE_TAG="${{ steps.parse-tag.outputs.pre_release_tag }}"
          cd "packages/$PACKAGE_NAME"
          
          # 检查版本是否已发布
          PACKAGE_FULL_NAME="@traceway/$PACKAGE_NAME"
          if npm view "$PACKAGE_FULL_NAME@$VERSION" version > /dev/null 2>&1; then
            echo "Version $VERSION of $PACKAGE_FULL_NAME already exists on npm, skipping publish"
            exit 0
          fi
          
          # 发布到 npm，预发布版本使用对应的 dist-tag
          if [ "$PRE_RELEASE_TAG" != "latest" ]; then
            echo "Publishing pre-release version $VERSION with dist-tag: $PRE_RELEASE_TAG"
            npm publish --access public --tag "$PRE_RELEASE_TAG"
          else
            echo "Publishing stable version $VERSION with dist-tag: latest"
            npm publish --access public
          fi
          
          echo "Successfully published $PACKAGE_FULL_NAME@$VERSION to npm (dist-tag: $PRE_RELEASE_TAG)"

      - name: Commit version updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          PACKAGE_NAME="${{ steps.parse-tag.outputs.package_name }}"
          VERSION="${{ steps.parse-tag.outputs.version }}"
          
          # 检查是否有更改
          if [ -n "$(git status --porcelain)" ]; then
            git add "packages/$PACKAGE_NAME/package.json"
            if [ -f "package.json" ]; then
              git add "package.json"
            fi
            git commit -m "chore: bump $PACKAGE_NAME version to $VERSION [skip ci]"
            git push
          else
            echo "No version changes to commit"
          fi

      - name: Create/Update git tag
        run: |
          TAG_NAME="${{ steps.parse-tag.outputs.tag_name }}"
          VERSION="${{ steps.parse-tag.outputs.version }}"
          
          # 检查 tag 是否已存在
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "Tag $TAG_NAME already exists, updating..."
            git tag -d "$TAG_NAME" || true
            git push origin ":refs/tags/$TAG_NAME" || true
          fi
          
          # 创建新 tag
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"
